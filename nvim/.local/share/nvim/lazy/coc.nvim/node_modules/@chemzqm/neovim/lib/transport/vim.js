"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VimTransport = void 0;
const constants_1 = require("../utils/constants");
const base_1 = __importDefault(require("./base"));
const connection_1 = __importDefault(require("./connection"));
const request_1 = __importDefault(require("./request"));
class VimTransport extends base_1.default {
    constructor(logger) {
        super(logger, true);
        this.pending = new Map();
        this.nextRequestId = -1;
        this.attached = false;
        /**
         * Cached error message
         */
        this.errText = '';
        /**
         * Cached out message
         */
        this.outText = '';
        this.notifyMethod = constants_1.isCocNvim ? 'coc#api#notify' : 'nvim#api#notify';
    }
    attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on('request', (id, obj) => {
            let [method, args] = obj;
            this.emit('request', method, args, this.createResponse(method, id));
        });
        connection.on('notification', (obj) => {
            let [event, args] = obj;
            this.emit('notification', event.toString(), args);
        });
        connection.on('response', (id, obj) => {
            let req = this.pending.get(id);
            if (req) {
                this.pending.delete(id);
                let err = null;
                let result = null;
                if (!Array.isArray(obj)) {
                    err = obj;
                }
                else {
                    err = obj[0];
                    result = obj[1];
                }
                req.callback(this.client, err, result);
            }
        });
    }
    send(arr) {
        this.connection.send(arr);
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.connection.dispose();
        for (let req of this.pending.values()) {
            req.callback(this.client, 'connection disconnected', null);
        }
        this.pending.clear();
    }
    /**
     * Send request to vim
     */
    request(method, args, cb) {
        if (!this.attached)
            return cb([0, 'transport disconnected']);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        // let startTs = Date.now()
        // if (debug) this.debug(`Send request "${method}" (${id}) to vim: `, args)
        let req = new request_1.default(this.connection, (err, res) => {
            // if (debug) this.debug(`Receive response "${method}" (${id}) from vim ${Date.now() - startTs}ms`, err ?? res)
            cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (this.pauseLevel != 0) {
            let arr = this.paused.get(this.pauseLevel);
            if (arr) {
                arr.push([method, args]);
                return;
            }
        }
        let fname = method.slice(5);
        if (fname == 'err_write') {
            this.errText = this.errText + args[0].toString();
            return;
        }
        if (fname == 'out_write') {
            let msg = args[0].toString() || '';
            if (!msg.includes('\n')) {
                this.outText = this.outText + msg;
            }
            else {
                let text = this.outText + args[0].toString();
                this.outText = '';
                this.connection.call(this.notifyMethod, [fname, [text]]);
            }
            return;
        }
        if (fname == 'err_writeln') {
            let text = this.errText + args[0].toString();
            this.errText = '';
            this.connection.call(this.notifyMethod, [fname, [text]]);
            return;
        }
        this.connection.call(this.notifyMethod, [fname, args]);
    }
    createResponse(method, requestId) {
        let called = false;
        let { connection } = this;
        // let startTs = Date.now()
        return {
            send: (resp, isError) => {
                if (called || !this.attached)
                    return;
                called = true;
                let err = null;
                if (isError)
                    err = typeof resp === 'string' ? resp : resp.toString();
                // if (debug) this.debug(`Send "${method}" (${requestId}) response to vim ${Date.now() - startTs}ms`)
                connection.response(requestId, [err, isError ? null : resp]);
            }
        };
    }
}
exports.VimTransport = VimTransport;
