"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = exports.level = exports.nullLogger = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const debugging = process.env.COC_NODE_CLIENT_DEBUG == '1' && process.env.COC_TESTER == '1';
exports.nullLogger = {
    debug: () => { },
    info: () => { },
    warn: () => { },
    error: () => { },
    trace: () => { },
};
function getLogFile() {
    let file = process.env.NODE_CLIENT_LOG_FILE;
    if (file)
        return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir)
        return path_1.default.join(dir, 'node-client.log');
    return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
}
const LOG_FILE_PATH = getLogFile();
exports.level = debugging ? 'debug' : process.env.NODE_CLIENT_LOG_LEVEL || 'info';
let invalid = !debugging && process.getuid && process.getuid() == 0;
if (!invalid && !debugging) {
    try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, '', { encoding: 'utf8', mode: 0o666 });
    }
    catch (_e) {
        invalid = true;
    }
}
function toObject(arg) {
    if (arg == null) {
        return arg;
    }
    if (Array.isArray(arg)) {
        return arg.map(o => toObject(o));
    }
    if (typeof arg == 'object' && typeof arg.prefix == 'string' && typeof arg.data == 'number') {
        return '[' + arg.prefix + arg.data + ']';
    }
    return arg;
}
function toString(arg) {
    if (debugging)
        return (0, util_1.inspect)(arg, { depth: null, colors: true, compact: false });
    if (arg == null)
        return String(arg);
    if (typeof arg == 'object')
        return JSON.stringify(arg, null, 2);
    return String(arg);
}
const toTwoDigits = (v) => v < 10 ? `0${v}` : v.toString();
const toThreeDigits = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
function toTimeString(currentTime) {
    return `${toTwoDigits(currentTime.getHours())}:${toTwoDigits(currentTime.getMinutes())}:${toTwoDigits(currentTime.getSeconds())}.${toThreeDigits(currentTime.getMilliseconds())}`;
}
class Logger {
    constructor(name) {
        this.name = name;
    }
    get stream() {
        if (this._stream)
            return this._stream;
        if (debugging) {
            this._stream = process.stdout;
        }
        else {
            this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: 'utf8' });
        }
        return this._stream;
    }
    getText(level, data, meta) {
        let more = '';
        if (meta.length) {
            let arr = toObject(meta);
            more = ' ' + arr.map(o => toString(o)).join(', ');
        }
        return `${toTimeString(new Date())} ${level.toUpperCase()} [${this.name}] - ${data}${more}\n`;
    }
    debug(data, ...meta) {
        if (exports.level != 'debug' || invalid)
            return;
        this.stream.write(this.getText('debug', data, meta));
    }
    info(data, ...meta) {
        if (invalid)
            return;
        this.stream.write(this.getText('info', data, meta));
    }
    warn(data, ...meta) {
        if (invalid)
            return;
        this.stream.write(this.getText('warn', data, meta));
    }
    error(data, ...meta) {
        if (invalid)
            return;
        let stream = debugging ? process.stderr : this.stream;
        stream.write(this.getText('error', data, meta));
    }
    trace(data, ...meta) {
        if (exports.level != 'trace' || invalid)
            return;
        this.stream.write(this.getText('trace', data, meta));
    }
}
function createLogger(name) {
    return new Logger(name);
}
exports.createLogger = createLogger;
