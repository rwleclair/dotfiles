"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("../utils/logger");
const debug = logger_1.level === 'debug';
const logger = (0, logger_1.createLogger)('transport');
class Transport extends events_1.EventEmitter {
    constructor(logger, isVim) {
        super();
        this.logger = logger;
        this.isVim = isVim;
        this.pauseLevel = 0;
        this.paused = new Map();
    }
    debug(key, ...meta) {
        if (!debug)
            return;
        logger.debug(key, ...meta);
    }
    info(key, ...meta) {
        logger.info(key, ...meta);
    }
    debugMessage(msg) {
        if (!debug)
            return;
        const msgType = msg[0];
        if (msgType == 0) {
            logger.debug('receive request:', msg.slice(1));
        }
        else if (msgType == 1) {
            // logger.debug('receive response:', msg.slice(1))
        }
        else if (msgType == 2) {
            logger.debug('receive notification:', msg.slice(1));
        }
        else {
            logger.debug('unknown message:', msg);
        }
    }
    pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
    }
    cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
            this.paused.delete(pauseLevel);
            this.pauseLevel = pauseLevel - 1;
        }
    }
    resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
            return isNotify ? null : Promise.resolve([[], null]);
        let obj = {};
        Error.captureStackTrace(obj);
        this.pauseLevel = pauseLevel - 1;
        let list = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list && list.length) {
            return new Promise((resolve, reject) => {
                if (!isNotify) {
                    return this.request('nvim_call_atomic', [list], (err, res) => {
                        if (err) {
                            let e = new Error(`call_atomic error: ${err[1]}`);
                            e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                            return reject(e);
                        }
                        if (Array.isArray(res) && res[1] != null) {
                            let [index, errType, message] = res[1];
                            let [fname, args] = list[index];
                            let e = new Error(`call_atomic request error on "${fname}": ${message}`);
                            e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                            this.logger.error(`call_atomic request error ${errType} on "${fname}"`, args, message, e);
                            return reject(e);
                        }
                        resolve(res);
                    });
                }
                this.notify('nvim_call_atomic', [list]);
                resolve(undefined);
            });
        }
        return isNotify ? null : Promise.resolve([[], undefined]);
    }
}
exports.default = Transport;
