"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseApi = void 0;
class BaseApi {
    constructor({ data, client, }) {
        this.data = data;
        if (client) {
            this.client = client;
        }
        else {
            Object.defineProperty(this, 'client', {
                value: this
            });
        }
    }
    get transport() {
        return this.client._transport;
    }
    equals(other) {
        try {
            return String(this.data) === String(other.data);
        }
        catch (e) {
            return false;
        }
    }
    async request(name, args = []) {
        Error.captureStackTrace(args);
        return new Promise((resolve, reject) => {
            this.transport.request(name, this.getArgsByPrefix(args), (err, res) => {
                if (err) {
                    let e = new Error(err[1]);
                    if (!name.endsWith('get_var')) {
                        let stack = args.stack;
                        e.stack = `Error: request error on "${name}" - ${err[1]}\n` + stack.split(/\r?\n/).slice(3).join('\n');
                        this.client.logError(`request error on "${name}"`, args, e);
                    }
                    reject(e);
                }
                else {
                    resolve(res);
                }
            });
        });
    }
    getArgsByPrefix(args) {
        // Check if class is Neovim and if so, should not send `this` as first arg
        if (this.prefix !== 'nvim_' && args[0] != this) {
            let id = this.transport.isVim ? this.data : this;
            return [id, ...args];
        }
        return args;
    }
    /** Retrieves a scoped variable depending on type (using `this.prefix`) */
    getVar(name) {
        return this.request(`${this.prefix}get_var`, [name]).then(res => res, _err => {
            return null;
        });
    }
    setVar(name, value, isNotify = false) {
        if (isNotify) {
            this.notify(`${this.prefix}set_var`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_var`, [name, value]);
    }
    /** Delete a scoped variable */
    deleteVar(name) {
        this.notify(`${this.prefix}del_var`, [name]);
    }
    /** Retrieves a scoped option depending on type of `this` */
    getOption(name) {
        return this.request(`${this.prefix}get_option`, [name]);
    }
    setOption(name, value, isNotify) {
        if (isNotify) {
            this.notify(`${this.prefix}set_option`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_option`, [name, value]);
    }
    /** `request` is basically the same except you can choose to wait forpromise to be resolved */
    notify(name, args = []) {
        this.transport.notify(name, this.getArgsByPrefix(args));
    }
    toJSON() {
        var _a;
        return (_a = this.data) !== null && _a !== void 0 ? _a : 0;
    }
}
exports.BaseApi = BaseApi;
